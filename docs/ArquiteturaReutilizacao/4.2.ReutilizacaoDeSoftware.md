## 4.2.1 Introdu√ß√£o

A reutiliza√ß√£o de software √© uma pr√°tica fundamental na engenharia de software que visa o aproveitamento de componentes, padr√µes e estruturas j√° existentes para desenvolver novas funcionalidades. Esta abordagem reduz o tempo de desenvolvimento, minimiza a duplica√ß√£o de c√≥digo e aumenta a confiabilidade do sistema atrav√©s do reuso de componentes j√° testados.

Neste projeto, implementamos um sistema de ondas de inimigos que demonstra a aplica√ß√£o pr√°tica de reutiliza√ß√£o de software atrav√©s do aproveitamento de padr√µes de projeto, arquitetura estabelecida e componentes de sistema j√° presentes na base de c√≥digo existente.

## 4.2.2 Metodologia

O desenvolvimento do sistema de ondas seguiu uma metodologia de an√°lise e identifica√ß√£o de componentes reutiliz√°veis, seguida pela integra√ß√£o destes componentes sem modifica√ß√£o de suas interfaces p√∫blicas. A estrat√©gia adotada priorizou:

1. **Identifica√ß√£o de Padr√µes Existentes**: An√°lise da arquitetura atual para identificar padr√µes GoF e estruturas reutiliz√°veis
2. **An√°lise de Compatibilidade**: Verifica√ß√£o da compatibilidade entre novos requisitos e componentes existentes
3. **Integra√ß√£o N√£o-Invasiva**: Implementa√ß√£o que preserva o comportamento dos componentes originais

## 4.2.3 Classifica√ß√£o das Formas de Reutiliza√ß√£o

O sistema de ondas implementado utiliza principalmente a abordagem de **Componentes** e **Servi√ßos** como formas de reutiliza√ß√£o de software:

### 4.2.3.1 Reutiliza√ß√£o por Componentes

**Defini√ß√£o**: Aproveitamento de m√≥dulos independentes e bem definidos que encapsulam funcionalidades espec√≠ficas, mantendo interfaces est√°veis para integra√ß√£o <a href="#REF5">[5]</a>.

**Aplica√ß√£o no Sistema de Ondas**:
- **EnemyFactory**: Componente de cria√ß√£o de inimigos reutilizado atrav√©s do m√©todo `create_enemy()`
- **SpriteComposite**: Componente de gerenciamento de sprites acessado via `sprite_manager.inimigos`
- **Level**: Componente de configura√ß√£o de mapa estendido com par√¢metro `spawn_enemies`

**Caracter√≠sticas Demonstradas**:
- Reutiliza√ß√£o sem modifica√ß√£o das interfaces originais
- Manuten√ß√£o do encapsulamento de responsabilidades
- Integra√ß√£o transparente atrav√©s de APIs estabelecidas

### 4.2.3.2 Reutiliza√ß√£o por Servi√ßos

**Defini√ß√£o**: Utiliza√ß√£o de funcionalidades oferecidas por m√≥dulos que fornecem servi√ßos espec√≠ficos de forma transparente <a href="#REF5">[5]</a>.

**Aplica√ß√£o no Sistema de Ondas**:
- **GameScreenRenderer**: Extens√£o do servi√ßo de renderiza√ß√£o para exibir informa√ß√µes de ondas
- **BaseScreen**: Aproveitamento da infraestrutura de telas para integra√ß√£o com MVC

**Caracter√≠sticas Demonstradas**:
- Extens√£o de funcionalidades sem alterar servi√ßos base
- Aproveitamento de abstra√ß√µes existentes
- Reutiliza√ß√£o de infraestrutura de UI e controle

## 4.2.4 Componentes Reutilizados

### 4.2.4.1 Padr√£o Prototype (GoF)

**Componente Original**: O sistema j√° possu√≠a implementa√ß√£o do padr√£o [Prototype](https://unbarqdsw2025-2-turma01.github.io/2025.2-T01-G1_JogoDigital_Entrega_03/PadroesDeProjeto/3.1.GoFsCriacionais/#315-prototype) para cria√ß√£o eficiente de inimigos atrav√©s da classe `EnemyFactory` em `src/Model/Enemies/EnemyPrototype.py` <a href="#REF1">[1]</a>.

**Reutiliza√ß√£o Aplicada**: O sistema de ondas utiliza diretamente o m√©todo `EnemyFactory.create_enemy()` para instancia√ß√£o de inimigos:

```python
# src/Model/Wave/WaveManager.py
    def _spawn_enemy(self, enemy_type: str, lane: int) -> bool:
        lane = max(0, min(lane, NUM_LINHAS - 1))
        spawn_x = NUM_COLUNAS - 1  
        
        enemy = EnemyFactory.create_enemy(enemy_type, spawn_x, lane)
        
        if enemy:
            print(f"[WaveManager] {enemy_type} spawnado na lane {lane}")
            return True
        else:
            print(f"[WaveManager] ERRO: Falha ao spawnar {enemy_type}")
            return False
```

**Benef√≠cio Obtido**: Elimina√ß√£o da necessidade de reimplementar l√≥gica de cria√ß√£o de inimigos, aproveitando sistema j√° testado e otimizado.

### 4.2.4.2 Padr√£o Composite (GoF)

**Componente Original**: O gerenciamento de sprites √© realizado atrav√©s do padr√£o Composite implementado na classe `SpriteComposite` (`src/Model/sprite_groups.py`), disponibilizada via inst√¢ncia global `sprite_manager`.

**Reutiliza√ß√£o Aplicada**: O sistema de ondas integra-se ao gerenciamento existente atrav√©s de tr√™s opera√ß√µes principais:

```python
# src/Model/Wave/WaveManager.py - Verifica√ß√£o de conclus√£o de onda
def _check_wave_completion(self) -> None:
    from Model.sprite_groups import sprite_manager
    
    if len(sprite_manager.inimigos) == 0:
        print(f"[WaveManager] Onda {self._current_wave} conclu√≠da!")
        self._state = WaveState.WAITING

# src/View/GameScreen/GameScreen.py - Limpeza de inimigos
sprite_manager.inimigos.empty()  # Limpa inimigos da inicializa√ß√£o

# src/Model/Wave/WaveManager.py - Contagem de inimigos restantes
def get_progress(self) -> Dict[str, any]:
    try:
        from Model.sprite_groups import sprite_manager
        enemies_remaining = len(sprite_manager.inimigos)
    except:
        enemies_remaining = 0
    
    return {
        'current_wave': self._current_wave,
        'total_waves': self._total_waves,
        'state': self._state.value,
        'enemies_remaining': enemies_remaining
    }
```



**Benef√≠cio Obtido**: Integra√ß√£o transparente com o sistema de renderiza√ß√£o e atualiza√ß√£o de sprites existente.

### 4.2.4.3 Padr√£o Strategy (GoF)

**Componente Original**: O projeto implementa o padr√£o Strategy no m√≥dulo `DifficultySelector` (`src/Core/DifficultySelector.py`) com estrutura hier√°rquica de classe abstrata e implementa√ß√µes concretas.

**Reutiliza√ß√£o Estrutural**: O sistema de ondas replica a mesma estrutura arquitetural do `DifficultySelector` <a href="#REF1">[1]</a>:

```python
# src/Core/DifficultySelector.py - Estrutura Original
class StrategyDifficulty(ABC):
    @abstractmethod
    def obter_multiplicador_vida(self) -> float:
        pass

class EasyStrategy(StrategyDifficulty):
    def obter_multiplicador_vida(self) -> float:
        return 0.7

# src/Model/Wave/WaveStrategy.py - Estrutura Reutilizada
class WaveStrategy(ABC):
    @abstractmethod
    def get_wave_enemies(self, wave_number: int) -> List[Dict[str, any]]:
        pass

class LinearWaveStrategy(WaveStrategy):
    def get_wave_enemies(self, wave_number: int) -> List[Dict[str, any]]:
        enemies = []
        enemy_count = 1 + wave_number
        
        for i in range(enemy_count):
            enemies.append({
                'type': 'bicho_papao',
                'lane': random.randint(0, 5),
                'delay': i * 2.0
            })
        
        return enemies
```

**Benef√≠cio Obtido**: Consist√™ncia arquitetural e facilidade de extens√£o com novas estrat√©gias de ondas.

### 4.2.4.4 Arquitetura MVC

**Componente Original**: O jogo segue arquitetura Model-View-Controller bem estabelecida com separa√ß√£o clara de responsabilidades <a href="#REF4">[4]</a>.

**Reutiliza√ß√£o Aplicada**: O sistema de ondas integra-se aos componentes MVC existentes:

```python
# src/View/GameScreen/GameScreen.py - Controller
class GameScreen(BaseScreen):
    def __init__(self):
        super().__init__()
        Level.inicializar_mapa(spawn_enemies=False)
        
        # Sistema de ondas integrado
        self.wave_manager = WaveManager("linear", total_waves=5)
        self.game_started = False
        
# src/View/GameScreen/GameScreen.py - Loop principal
def update(self):
    if self.game_started and not self.state_vars['GAME_PAUSED']:
        self.wave_manager.update(1/60)  # 60 FPS
        
        if self.wave_manager.is_all_waves_complete() and not self.game_completed:
            self._complete_game()
    
# src/View/GameScreen/GameScreenRenderer.py - View extension
def _draw_wave_info(self, surface):
    wave_info = self.screen.get_wave_info()
    if not wave_info:
        return
    
    if not wave_info['game_started']:
        text1 = self.font.render("Pressione G para iniciar o jogo", True, (255, 255, 0))
        surface.blit(text1, (info_x, info_y))
```

**Benef√≠cio Obtido**: Preserva√ß√£o da arquitetura existente sem necessidade de reestrutura√ß√£o.

### 4.2.4.5 Sistema de N√≠veis

**Componente Original**: Classe `Level` com m√©todo `inicializar_mapa()` respons√°vel pela configura√ß√£o inicial do campo de jogo.

**Reutiliza√ß√£o com Extens√£o Compat√≠vel**: Adi√ß√£o de par√¢metro opcional mantendo retrocompatibilidade:

```python
# src/Model/Level/level.py - Implementa√ß√£o estendida
@classmethod
def inicializar_mapa(cls, spawn_enemies: bool = False):
    """
    Inicializa o mapa l√≥gico e opcionalmente a popula√ß√£o inicial.
    
    Args:
        spawn_enemies: Se True, spawna inimigos automaticamente.
                      Se False, deixa para o WaveManager controlar.
    """
    cls.MAPA_LOGICO = [[0] * NUM_COLUNAS for _ in range(NUM_LINHAS)] 
    
    for linha in range(NUM_LINHAS):
        cls.MAPA_LOGICO[linha][0] = 1 
        Caipora(0, linha)

    # Spawna inimigos apenas se solicitado (compatibilidade com sistema antigo)
    if spawn_enemies:
        linha_bp = random.randint(0, NUM_LINHAS - 1)
        EnemyFactory.create_enemy("bicho_papao", NUM_COLUNAS - 1, linha_bp)
```

**Benef√≠cio Obtido**: Controle sobre spawn inicial de inimigos sem quebrar funcionalidade existente.

## 4.2.5 An√°lise de Impacto

### 4.2.5.1 Compatibilidade

Todos os componentes originais mantiveram suas interfaces p√∫blicas inalteradas, garantindo:

- Funcionalidade existente preservada
- Possibilidade de rollback sem impacto
- Extensibilidade futura mantida

### 4.2.5.2 Qualidade de Software

A aplica√ß√£o de reutiliza√ß√£o resultou em:

- **Manutenibilidade**: Mudan√ßas nos componentes base beneficiam automaticamente o sistema de ondas
- **Confiabilidade**: Reutiliza√ß√£o de componentes j√° testados reduz probabilidade de bugs
- **Consist√™ncia**: Padr√µes arquiteturais uniformes em todo o projeto

## 4.2.6 Conclus√µes

A implementa√ß√£o do sistema de ondas demonstra a aplica√ß√£o pr√°tica da reutiliza√ß√£o de software atrav√©s do aproveitamento de padr√µes de projeto (Prototype, Composite, Strategy), arquitetura estabelecida (MVC) e componentes de sistema existentes.

A abordagem n√£o-invasiva adotada permitiu a integra√ß√£o completa da nova funcionalidade sem modificar interfaces p√∫blicas dos componentes originais, preservando a funcionalidade existente e mantendo a consist√™ncia arquitetural do projeto.

Os benef√≠cios obtidos incluem redu√ß√£o significativa no tempo de desenvolvimento, maior confiabilidade atrav√©s do reuso de componentes testados, e facilidade de manuten√ß√£o atrav√©s da preserva√ß√£o dos padr√µes arquiteturais estabelecidos.

## 4.2.8. V√≠deo Demonstrativo

<div style="text-align: center;">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/7ycLqVeUT28" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

## 4.2.9. Opini√µes dos Participantes

<details>
  <summary><strong><a href="https://github.com/EnzoEmir">Enzo Emir</a></strong></summary>
  <p>Acho muito interessante o conceito de reutiliza√ß√£o de c√≥digo. √â exatamente o que o mercado espera de um bom programador: entregas mais r√°pidas, c√≥digo limpo e de f√°cil manuten√ß√£o. No entanto, eu n√£o tinha ideia de quantos tipos diferentes de reutiliza√ß√£o realmente existem. </p>
</details>

## 4.2.10. Refer√™ncias Bibliogr√°ficas

> <a id="REF1">1.</a> GAMMA, Erich et al. **Padr√µes de Projeto: Solu√ß√µes Reutiliz√°veis de Software Orientado a Objetos**. Tradu√ß√£o de C. F. Lucena e F. S. C. da Silva. Porto Alegre: Bookman, 2007. (T√≠tulo original: _Design Patterns: Elements of Reusable Object-Oriented Software_).

> <a id="REF2">2.</a> DEV MEDIA. Padr√£o de Projeto Facade em Java. DevMedia. Dispon√≠vel em: https://www.devmedia.com.br/padrao-de-projeto-facade-em-java/26476. Acesso em: 20 nov. 2025.

> <a id="REF3">3.</a> REFACTORING.GURU. Facade. Refactoring.Guru. Dispon√≠vel em: https://refactoring.guru/pt-br/design-patterns/facade. Acesso em: 20 nov. 2025.

> <a id="REF4">4.</a> DEV MEDIA. Padr√£o MVC - Java Magazine. DevMedia. Dispon√≠vel em: https://www.devmedia.com.br/padrao-mvc-java-magazine/21995. Acesso em: 20 nov. 2025.

> <a id="REF5">5.</a> SERRANO, Milene. Aula ‚Äì GOFs Comportamentais. Arquitetura e Desenho de Software. Universidade de Bras√≠lia ‚Äì UnB Gama, [s.d.]. Material de aula (apresenta√ß√£o de slides).

## 4.2.11. Hist√≥rico de Vers√µes üìÖ

| Vers√£o |    Data    |                Descri√ß√£o                |                  Autor(es)                   |                    Revisor(es)                     |
| :----: | :--------: | :-------------------------------------: | :------------------------------------------: | :------------------------------------------------: |
| `0.1`  | 20/11/2025 | Cria√ß√£o da pagina e documenta√ß√£o do Sistema de Waves | [Enzo Emir](https://github.com/EnzoEmir) | - |