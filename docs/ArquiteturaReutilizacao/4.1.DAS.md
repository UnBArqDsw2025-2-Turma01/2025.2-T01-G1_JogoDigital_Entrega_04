# 4.1 Documento de Arquitetura de  Software (DAS)

## Introdu√ß√£o
Este Documento de Arquitetura de Software apresenta uma vis√£o geral abrangente da estrutura e organiza√ß√£o do sistema, descrevendo seus principais componentes, seus relacionamentos e as decis√µes arquiteturais que orientam o desenvolvimento. Ele serve como refer√™ncia central para todos os envolvidos no projeto, garantindo entendimento comum sobre como o sistema foi projetado e como dever√° evoluir ao longo do seu ciclo de vida.

A introdu√ß√£o oferece o contexto necess√°rio para compreender o documento, incluindo sua finalidade, escopo, termos relevantes e organiza√ß√£o geral. Com isso, estabelece a base para uma comunica√ß√£o clara entre analistas, arquitetos, desenvolvedores, testadores e demais stakeholders.

### Prop√≥sito
O objetivo deste documento √© capturar, comunicar e justificar as decis√µes arquiteturais essenciais do sistema. Por meio de diferentes vis√µes arquiteturais ‚Äî como l√≥gica, processos, implanta√ß√£o e implementa√ß√£o ‚Äî ele descreve como o sistema ser√° estruturado para atender aos requisitos funcionais e n√£o funcionais.

Este documento guia equipes t√©cnicas durante o desenvolvimento, manuten√ß√£o e evolu√ß√£o da solu√ß√£o, oferecendo:

- Um entendimento consistente e compartilhado sobre a arquitetura.

- Diretrizes para implementa√ß√£o, padr√µes e restri√ß√µes.

- Visibilidade sobre decis√µes cr√≠ticas que impactam desempenho, seguran√ßa, escalabilidade e qualidade geral do sistema.

Suporte ao planejamento, estimativas e integra√ß√£o entre equipes.

Destina-se a arquitetos, desenvolvedores, engenheiros de infraestrutura, analistas e demais partes interessadas que necessitam compreender como o sistema foi projetado ou como dever√° ser expandido no futuro.

### Escopo
O presente documento se aplica ao desenvolvimento de um jogo Tower Defense, inspirado no estilo Plants vs Zombies, com tem√°tica do folclore brasileiro. O sistema abranger√° os seguintes recursos principais:

- Menu de Tela Inicial: ponto de entrada do jogador, contendo op√ß√µes de navega√ß√£o.

- Sele√ß√£o de Mapas: escolha do cen√°rio em que a partida ser√° realizada.

- Sele√ß√£o de Dificuldade: defini√ß√£o do n√≠vel de desafio da partida.

- Loja de Personagens: espa√ßo para aquisi√ß√£o de personagens utilizando recursos do jogo.

- Escolha de Personagens para Partida: sele√ß√£o estrat√©gica dos personagens que participar√£o do combate.

- Configura√ß√µes de √Åudio: ajustes de m√∫sica e efeitos sonoros.

O objetivo principal do jogo √© sobreviver at√© o final da onda de inimigos, utilizando estrat√©gias e personagens adquiridos na loja para defender o mapa.

### Defini√ß√£o
Esta se√ß√£o apresenta os termos, acr√¥nimos e abrevia√ß√µes utilizados no documento, garantindo entendimento consistente entre todos os leitores.

**Defini√ß√µes**

- **Jogo Tower Defense**: g√™nero de jogo em que o jogador deve impedir que inimigos alcancem um objetivo, posicionando unidades defensivas estrategicamente.

**Orda**: conjunto de inimigos que avan√ßa em sequ√™ncia durante a partida.

**Personagem**: unidade jog√°vel ou defensiva que possui habilidades espec√≠ficas para combater os inimigos.

**Mapa**: cen√°rio do jogo onde ocorre a partida.

**Loja**: funcionalidade do jogo que permite ao jogador adquirir personagens ou recursos utilizando moedas ou pontos do jogo.

**Dificuldade**: n√≠vel de desafio da partida, que pode influenciar a quantidade e for√ßa dos inimigos.


<!-- 
Acr√¥nimos
**UC**: User Interface (Interface do Usu√°rio)

**XP**: Experience Points (Pontos de Experi√™ncia)

**HP**: Health Points (Pontos de Vida)

Abreviaturas

**Lvl**: Level (N√≠vel)

**Cf**: Configura√ß√£o -->

## Vis√£o Geral

Esta se√ß√£o fornece uma vis√£o geral do sistema e da estrutura deste documento de arquitetura, explicando como as informa√ß√µes est√£o organizadas e como devem ser interpretadas pelos leitores.

O sistema √© um jogo Tower Defense com tem√°tica do folclore brasileiro, inspirado no estilo Plants vs Zombies. O jogador deve sobreviver √†s ondas de inimigos, utilizando personagens estrat√©gicos adquiridos na loja e escolhidos para a partida, enfrentando diferentes mapas e n√≠veis de dificuldade.

O documento est√° organizado em se√ß√µes que representam diferentes vis√µes arquiteturais do sistema:

- **Arquitetura e Representa√ß√£o**: descreve como a arquitetura do software √© representada e quais modelos ser√£o utilizados.

- **Metas e Restri√ß√µes Arquiteturais**: apresenta objetivos e restri√ß√µes que influenciam diretamente a arquitetura do sistema.

<!-- - **Use-Case View**: detalha os casos de uso principais, mostrando a funcionalidade central do jogo. -->

- **Logical View**: descreve a decomposi√ß√£o do sistema em subsistemas, pacotes e classes significativas.

- **Process View**: detalha os processos do sistema e a forma como interagem entre si.

- **Deployment View**: mostra a configura√ß√£o f√≠sica de hardware onde o software ser√° executado.

- **Implementation View**: apresenta a estrutura de implementa√ß√£o, incluindo camadas e componentes do sistema.

- **Data View (opcional)**: descreve a perspectiva de armazenamento persistente de dados, caso aplic√°vel.

- **Tamanho, Desempenho e Qualidade**: define os principais par√¢metros de dimensionamento, desempenho e atributos de qualidade do sistema.

Esta organiza√ß√£o permite que diferentes stakeholders (arquitetos, desenvolvedores, testadores e gerentes) compreendam o sistema de acordo com suas necessidades, facilitando tomada de decis√£o, manuten√ß√£o e evolu√ß√£o do jogo.

---

## Representa√ß√£o Arquitetural

O presente jogo adotar√° a arquitetura em camadas, alinhada como uma variante padr√£o Model-View-Template (MVT). Trata-se de uma varia√ß√£o pois a uma camada central/intermedi√°ria entre as demais camadas, chamada **Core**. Essa abordagem organiza o sistema em quatro componentes principais, cada um com fun√ß√µes bem definidas.


### Justificativa
A escolha de uma variante da arquitetura MVT, foi motivada por suas diversas vantagens, que se alinham diretamente √†s necessidades do desenvolvimento do jogo desenvolvido com PyGame. Entre os principais benef√≠cios, destacam-se:

#### Separa√ß√£o de Responsabilidades

<div style="text-align: justify;">

A arquitetura MVT separa claramente as fun√ß√µes do sistema, o que:

<ul>
    <li>Facilita a manuten√ß√£o e a evolu√ß√£o independente de cada componente. </li>
    <li>Permite altera√ß√µes no <strong>Template</strong> (interface do usu√°rio) sem impactar a l√≥gica de neg√≥cios no <strong>Model</strong>.</li>
    <li>Simplifica o desenvolvimento cont√≠nuo e modular do sistema.</li>
</ul>

</div>

#### Facilidade de Teste

<div style="text-align: justify;">

Com a atual arquitetura, as camadas podem ser testadas isoladamente:

</div>

- <strong>Models</strong> podem ser validados com testes unit√°rios para garantir a integridade dos dados.
- <strong>Views</strong> podem ser testadas para confirmar o comportamento esperado das requisi√ß√µes.
- <strong>Templates</strong> podem ser revisados para verificar se os dados est√£o sendo apresentados corretamente.
- <strong>Core</strong> a l√≥gica pode ser testa e feita de forma independente de forma que pode-se auxiliar de logs de console, sem depender das demais camadas.

#### Desenvolvimento Paralelo

<div style="text-align: justify;">

A separa√ß√£o em camadas permite que diferentes equipes trabalhem simultaneamente:

</div>

- Uma equipe pode desenvolver os <strong>Models</strong>, configurando o banco de dados e regras de neg√≥cio.
- Outra pode focar na cria√ß√£o de <strong>Templates</strong> e no design das telas.
- Uma terceira equipe pode trabalhar nas <strong>Views</strong>, integrando os dados e ajustando a l√≥gica.

#### Escalabilidade e Adapta√ß√£o

<div style="text-align: justify;">

A arquitetura MVT √© flex√≠vel e escal√°vel, permitindo que novas funcionalidades sejam adicionadas ou modificadas com facilidade. Isso √© crucial para suportar expans√µes futuras, como novos m√≥dulos para gerenciamento de eventos ou integra√ß√£o com novos sistemas.
</div>

## Metas e Restri√ß√µes Arquiteturais

### Metas

As metas arquiteturais do sistema foram definidas para atender √†s necessidades funcionais e n√£o funcionais do jogo, garantindo desempenho, manutenibilidade e experi√™ncia de usu√°rio de qualidade.

#### Modularidade e Manutenibilidade

O sistema deve ser modular, permitindo que novas funcionalidades ‚Äî como personagens, inimigos, mapas ou modos de jogo ‚Äî sejam adicionadas sem impactar componentes existentes.
Justificativa: A arquitetura modular facilita corre√ß√µes, atualiza√ß√µes e expans√µes futuras do jogo.

#### Desempenho em Tempo Real

O jogo deve manter uma taxa de atualiza√ß√£o (FPS) consistente durante as partidas, mesmo com v√°rias unidades e efeitos gr√°ficos simult√¢neos.
Justificativa: O desempenho em tempo real √© cr√≠tico para garantir a jogabilidade fluida e a experi√™ncia do jogador.

#### Portabilidade

O jogo deve ser compat√≠vel com m√∫ltiplos sistemas operacionais desktop, incluindo Windows, Linux e macOS.
Justificativa: Garantir portabilidade aumenta o alcance do jogo e permite que mais usu√°rios possam jog√°-lo sem problemas de compatibilidade.

### Restri√ß√µes 

#### Uso do Pygame

O desenvolvimento ser√° baseado no Pygame, aproveitando suas funcionalidades para renderiza√ß√£o, entrada do usu√°rio, √°udio e gerenciamento de eventos.
Justificativa: O Pygame √© leve, f√°cil de usar, amplamente suportado e adequado para jogos 2D como este Tower Defense e √© uma escolha ideal para a disciplina em virtude que √© preciso total controle sobre a ferramenta para aplicar os conceitos estudados na disciplina.

#### Estrutura MVT Adaptada

O jogo seguir√° uma arquitetura MVT (Model-View-Template) adaptada para Pygame:

Model: dados de personagens, inimigos, mapas e estado da partida.

Template: recursos visuais e telas (menus, HUD, telas de vit√≥ria/derrota).

View: renderiza√ß√£o din√¢mica de sprites, anima√ß√µes e interface durante o jogo.

Core: Adicionar descri√ß√£o

Justificativa: A separa√ß√£o clara de responsabilidades permite manuten√ß√£o mais simples e evolu√ß√£o do sistema sem impacto em outras camadas.

#### Armazenamento Local

O jogo usar√° arquivos locais (por exemplo, JSON ou SQLite) para salvar progresso, configura√ß√µes de √°udio, moedas e desbloqueio de personagens.

**Justificativa**: O armazenamento local √© suficiente para o escopo inicial e garante persist√™ncia dos dados entre partidas.


---

<!-- ## Use-Case View
*This section lists use cases or scenarios from the use-case model if they represent some significant, central functionality of the final system, or if they have a large architectural coverage‚Äîthey exercise many architectural elements or if they stress or illustrate a specific, delicate point of the architecture.*

### Use-Case Realizations
*This section illustrates how the software actually works by giving a few selected use-case (or scenario) realizations, and explains how the various design model elements contribute to their functionality.* -->


## Logical View

A Logical View descreve a organiza√ß√£o interna do sistema em pacotes, classes e componentes significativos, mostrando como a l√≥gica do jogo est√° estruturada. O objetivo √© evidenciar responsabilidades, depend√™ncias e a modularidade da arquitetura.

O sistema est√° organizado em quatro pacotes principais, seguindo a arquitetura adaptada MVT (Model-View-Template) com Core central, para ilustrar melhor ser√° utilizado o diagrama de pacotes:

![Diagrama L√≥gico](../assets/diagrama_logico.svg)
<font size="2"><p style="text-align: center">Fonte: Caio Duarte, Victor Pontual, 2025.</p></font>

Para uma visualiza√ß√£o melhor clique aqui: [Ver diagrama no Lucidchart](https://lucid.app/lucidchart/be7a1922-e575-4671-89e9-462b6a013c2f/edit?viewport_loc=-2145%2C-1045%2C4810%2C2701%2C0_0&invitationId=inv_a4c33e9d-48df-4e0b-ab72-471d041ad7b3)

<details>
  <summary>Core</summary>
  <p><strong>Fun√ß√£o:</strong> Coordena o fluxo principal do jogo, gerenciando eventos, telas e a intera√ß√£o entre Model, View e Template.</p>
  <p><strong>Principais Classes/Componentes:</strong></p>
  <ul>
    <li><strong>GameMain:</strong> classe central que inicia e gerencia o loop principal do jogo.</li>
    <li><strong>ScreenManager:</strong> gerencia a troca de telas (menus, gameplay, vit√≥ria/derrota).</li>
    <li><strong>DifficutySelector:</strong> permite selecionar a dificuldade do mapa.</li>
  </ul>
  <p><strong>Depend√™ncias:</strong></p>
  <ul>
    <li>Interage com Model para obter estados do jogo.</li>
    <li>Interage com View para renderizar as telas.</li>
    <li>Interage com Template para exibir elementos visuais padronizados.</li>
  </ul>
</details>

<details>
  <summary>Model</summary>
  <p><strong>Fun√ß√£o:</strong> Cont√©m entidades do jogo e regras de neg√≥cio, gerenciando dados persistentes e estados internos.</p>
  <p><strong>Principais Classes/Componentes:</strong></p>
  <ul>
    <li><strong>Enemies:</strong> armazena informa√ß√µes das tropas inimigas.</li>
    <li><strong>Defense:</strong> armazena informa√ß√µes das tropas alidas.</li>
    <li><strong>Items:</strong> armazena informa√ß√µes de items.</li>
    <li><strong>Level:</strong> armazena informa√ß√µes do level.</li>
    <li><strong>Wave:</strong> armazena informa√ß√µes da onda de inimigos.</li>
  </ul>
  <p><strong>Depend√™ncias:</strong></p>
  <ul>
    <li>Fornece dados para Core e View.</li>
    <li>Persist√™ncia local atrav√©s de JSON ou SQLite.</li>
  </ul>
</details>

<details>
  <summary>View</summary>
  <p><strong>Fun√ß√£o:</strong> Respons√°vel por renderizar o jogo em tempo real, exibindo sprites, anima√ß√µes e interface.</p>
  <p><strong>Principais Classes/Componentes:</strong></p>
  <ul>
    <li><strong>ViewRenderer:</strong> Define a interface de renderiza√ß√£o e desenha os elementos visuais na tela.</li>
    <li><strong>InputHandler:</strong> Gerencia a interface de entradas e captura as a√ß√µes do usu√°rio.</li>
    <li><strong>DifficultScreen:</strong> Tela respons√°vel pela sele√ß√£o do n√≠vel de dificuldade do jogo.</li>
    <li><strong>LevelSelectScreen:</strong> Tela que permite ao jogador escolher a fase ou n√≠vel desejado.</li>
    <li><strong>GameScreen:</strong> Tela principal onde ocorre a jogabilidade (gameplay) ativa.</li>
    <li><strong>MenuScreen:</strong> Tela de menu principal (iniciar jogo, op√ß√µes, cr√©ditos).</li>
    <li><strong>Modal:</strong> Janelas sobrepostas para avisos, pausas ou confirma√ß√µes r√°pidas.</li>
</ul>
  <p><strong>Depend√™ncias:</strong></p>
  <ul>
    <li>Consulta Model para obter dados a serem renderizados.</li>
    <li>Utiliza Template para componentes visuais padronizados.</li>
  </ul>
</details>

<details>
  <summary>Template</summary>
  <p><strong>Fun√ß√£o:</strong> Cont√©m elementos visuais, telas e recursos reutiliz√°veis, garantindo consist√™ncia est√©tica do jogo.</p>
  <p><strong>Principais Classes/Componentes:</strong></p>
  <ul>
    <ul>
        <li><strong>BaseScreens:</strong> Classe base abstrata que define as telas do jogo.</li>
        <li><strong>PhysicsEngine:</strong> Respons√°vel pelos c√°lculos de f√≠sica, detec√ß√£o de colis√µes e simula√ß√£o de movimento dos objetos.</li>
        <li><strong>Modal:</strong> Componente de interface sobreposta utilizado para alertas, menus de pausa e confirma√ß√µes que interrompem o fluxo principal.</li>
        <li><strong>UIConfigs:</strong> Interface de configura√ß√µes.</li>
        <li><strong>TemplateRenderer:</strong> Gerencia a renderiza√ß√£o de modelos visuais padronizados e layouts reutiliz√°veis para garantir consist√™ncia visual.</li>
    </ul>

  </ul>
  <p><strong>Depend√™ncias:</strong></p>
  <ul>
    <li>Utilizada por View para renderiza√ß√£o.</li>
    <li>Pode ser acessada por Core para exibir mensagens ou notifica√ß√µes.</li>
  </ul>
</details>

<details>
  <summary>Rela√ß√µes entre os pacotes</summary>
  <ul>
    <li>Core ‚Üí Model: consulta e atualiza estados do jogo.</li>
    <li>Core ‚Üí View: solicita renderiza√ß√£o de tela e elementos gr√°ficos.</li>
    <li>Core ‚Üí Template: utiliza elementos visuais padronizados.</li>
    <li>View ‚Üí Model: l√™ dados para renderiza√ß√£o din√¢mica.</li>
    <li>View ‚Üí Template: exibe componentes reutiliz√°veis.</li>
    <li>Template ‚Üí Nenhuma camada inferior: apenas fornece recursos visuais.</li>
  </ul>

</details>


### Overview

O sistema est√° decomposto em quatro pacotes principais que seguem uma arquitetura em camadas:

1. **Core**: Camada central que gerencia o fluxo principal do jogo e a coordena√ß√£o entre componentes.

2. **View**: Camada de apresenta√ß√£o respons√°vel pela renderiza√ß√£o visual e interface com o usu√°rio.

3. **Model**: Camada de dom√≠nio contendo as entidades e l√≥gica de neg√≥cio do jogo.

4. **Template**: Camada de recursos reutiliz√°veis que fornece componentes visuais padronizados.


A organiza√ß√£o segue o princ√≠pio de separa√ß√£o de responsabilidades, onde cada camada possui um papel bem definido e se comunica com as demais atrav√©s de interfaces estabelecidas.

<!-- ### Architecturally Significant Design Packages
*For each significant package, include a subsection with its name, its brief description, and a diagram with all significant classes and packages contained within the package.*

*For each significant class in the package, include its name, brief description, and, optionally, a description of some of its major responsibilities, operations, and attributes.* -->

<!-- 

## Process View
*This section describes the system's decomposition into lightweight processes (single threads of control) and heavyweight processes (groupings of lightweight processes). Organize the section by groups of processes that communicate or interact. Describe the main modes of communication between processes, such as message passing, interrupts, and rendezvous.*

---

## Deployment View
*This section describes one or more physical network (hardware) configurations on which the software is deployed and run. It is a view of the Deployment Model. At a minimum for each configuration it should indicate the physical nodes (computers, CPUs) that execute the software and their interconnections (bus, LAN, point-to-point, and so on.) Also include a mapping of the processes of the Process View onto the physical nodes.*

---

## Implementation View
*This section describes the overall structure of the implementation model, the decomposition of the software into layers and subsystems in the implementation model, and any architecturally significant components.*

### Overview
*This subsection names and defines the various layers and their contents, the rules that govern the inclusion to a given layer, and the boundaries between layers. Include a component diagram that shows the relations between layers.*

### Layers
*For each layer, include a subsection with its name, an enumeration of the subsystems located in the layer, and a component diagram.*

---

## Data View (optional)
*A description of the persistent data storage perspective of the system. This section is optional if there is little or no persistent data, or the translation between the Design Model and the Data Model is trivial.*

--- -->

## Tamanho e Performace
O sistema deve ser projetado para ser leve e eficiente, garantindo uma boa experi√™ncia de jogo mesmo em computadores com recursos limitados. Os principais aspectos de dimensionamento e desempenho incluem:

- N√∫mero de Entidades na Tela: o jogo deve suportar m√∫ltiplos personagens e inimigos simultaneamente sem queda percept√≠vel de FPS.

- Resolu√ß√£o e Tela: suporte a diferentes resolu√ß√µes de tela, mantendo propor√ß√£o e desempenho adequado.

- Recursos Gr√°ficos e √Åudio: sprites, anima√ß√µes e efeitos sonoros s√£o carregados de forma otimizada para reduzir consumo de mem√≥ria.

- Atualiza√ß√µes em Tempo Real: o loop principal do jogo foi estruturado para processar eventos, l√≥gica de jogo e renderiza√ß√£o de forma eficiente, garantindo fluidez em partidas intensas.

- Limites de Performance: o objetivo √© manter 60 FPS est√°veis em hardware de configura√ß√£o m√©dia, com varia√ß√µes m√≠nimas durante picos de a√ß√£o.

**Justificativa**: O controle do tamanho e da complexidade do jogo impacta diretamente a arquitetura, influenciando decis√µes de modularidade, otimiza√ß√£o de renderiza√ß√£o e gerenciamento de mem√≥ria.

---

## Quality
A arquitetura do jogo contribui para atributos de qualidade al√©m da funcionalidade principal, garantindo uma experi√™ncia robusta e sustent√°vel:

**Extensibilidade**: a arquitetura MVT (Model-Template-View) adaptada permite adicionar novos personagens, inimigos, mapas ou modos de jogo sem impactar o c√≥digo existente.

**Manutenibilidade**: m√≥dulos bem definidos e a separa√ß√£o clara entre l√≥gica (Model), interface (Template) e renderiza√ß√£o (View) facilitam corre√ß√µes, atualiza√ß√µes e integra√ß√£o de novos desenvolvedores.

**Portabilidade**: o jogo √© compat√≠vel com m√∫ltiplos sistemas operacionais (Windows, Linux e macOS), permitindo que a base de usu√°rios seja ampliada.

**Confiabilidade**: o Model centraliza o estado do jogo, garantindo consist√™ncia entre visualiza√ß√£o e dados, evitando erros ou comportamentos inesperados.

**Desempenho**: o design modular e a otimiza√ß√£o de loops de renderiza√ß√£o garantem fluidez e resposta r√°pida, mesmo com m√∫ltiplas unidades na tela.

**Seguran√ßa e Privacidade**: dados locais do jogador (como progresso e compras na loja) s√£o armazenados de forma segura e local, a integridade desses dados s√£o por conta do jogador.

Justificativa: A arquitetura escolhida sustenta todos os atributos de qualidade, permitindo que o jogo seja escal√°vel, eficiente e agrad√°vel ao jogador sem comprometer a integridade do sistema.

### Refer√™ncias
- G1. *Modelagem*. Dispon√≠vel em: [https://unbarqdsw2025-2-turma01.github.io/2025.2-T01-G1_JogoDigital_Entrega_02/Modelagem/2.Modelagem/](https://unbarqdsw2025-2-turma01.github.io/2025.2-T01-G1_JogoDigital_Entrega_02/Modelagem/2.Modelagem/). Acesso em: 20 nov. 2025.

- SERRANO, Milene. *Software Architecture Document*. Dispon√≠vel em: [https://aprender3.unb.br/pluginfile.php/3178407/mod_page/content/1/Software%20Architecture%20Document.doc](https://aprender3.unb.br/pluginfile.php/3178407/mod_page/content/1/Software%20Architecture%20Document.doc). Acesso em: 20 nov. 2025.



## Hist√≥rico de Vers√µes üìÖ

| Vers√£o | Data | Descri√ß√£o | Autor(es) | Revisor(es) |
| :--: | :--: | :--: | :--: | :--: |
| `0.1` | 20/11/2025 | Adicionando Base do DAS | [Caio Duarte](https://github.com/caioduart3), [Victor Pontual](https://github.com/VictorPontual) | [Enzo Emir](https://github.com/EnzoEmir) |
| `0.2` | 20/11/2025 | Adicionando Logical View |[Caio Duarte](https://github.com/caioduart3), [Victor Pontual](https://github.com/VictorPontual) | [Enzo Emir](https://github.com/EnzoEmir) |
